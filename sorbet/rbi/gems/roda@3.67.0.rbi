# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `roda` gem.
# Please instead update this file by running `bin/tapioca gem roda`.

# The main class for Roda.  Roda is built completely out of plugins, with the
# default plugin being Roda::RodaPlugins::Base, so this class is mostly empty
# except for some constants.
#
# source://roda//lib/roda/cache.rb#5
class Roda
  include ::Roda::RodaPlugins::Base::InstanceMethods
  extend ::Roda::RodaPlugins::Base::ClassMethods
end

# A thread safe cache class, offering only #[] and #[]= methods,
# each protected by a mutex.
#
# source://roda//lib/roda/cache.rb#8
class Roda::RodaCache
  # Create a new thread safe cache.
  #
  # @return [RodaCache] a new instance of RodaCache
  #
  # source://roda//lib/roda/cache.rb#10
  def initialize; end

  # Make getting value from underlying hash thread safe.
  #
  # source://roda//lib/roda/cache.rb#16
  def [](key); end

  # Make setting value in underlying hash thread safe.
  #
  # source://roda//lib/roda/cache.rb#21
  def []=(key, value); end

  # Return the frozen internal hash.  The internal hash can then
  # be accessed directly since it is frozen and there are no
  # thread safety issues.
  #
  # source://roda//lib/roda/cache.rb#28
  def freeze; end

  private

  # Create a copy of the cache with a separate mutex.
  #
  # source://roda//lib/roda/cache.rb#35
  def initialize_copy(other); end
end

# Error class raised by Roda
#
# source://roda//lib/roda.rb#15
class Roda::RodaError < ::StandardError; end

# The major version of Roda, updated only for major changes that are
# likely to require modification to Roda apps.
#
# source://roda//lib/roda/version.rb#4
Roda::RodaMajorVersion = T.let(T.unsafe(nil), Integer)

# The minor version of Roda, updated for new feature releases of Roda.
#
# source://roda//lib/roda/version.rb#7
Roda::RodaMinorVersion = T.let(T.unsafe(nil), Integer)

# The patch version of Roda, updated only for bug fixes from the last
# feature release.
#
# source://roda//lib/roda/version.rb#11
Roda::RodaPatchVersion = T.let(T.unsafe(nil), Integer)

# Module in which all Roda plugins should be stored. Also contains logic for
# registering and loading plugins.
#
# source://roda//lib/roda/request.rb#26
module Roda::RodaPlugins
  class << self
    # Deprecate the constant with the given name in the given module,
    # if the ruby version supports it.
    #
    # source://roda//lib/roda/plugins.rb#45
    def deprecate_constant(mod, name); end

    # If the registered plugin already exists, use it.  Otherwise,
    # require it and return it.  This raises a LoadError if such a
    # plugin doesn't exist, or a RodaError if it exists but it does
    # not register itself correctly.
    #
    # source://roda//lib/roda/plugins.rb#26
    def load_plugin(name); end

    # Register the given plugin with Roda, so that it can be loaded using #plugin
    # with a symbol.  Should be used by plugin files. Example:
    #
    #   Roda::RodaPlugins.register_plugin(:plugin_name, PluginModule)
    #
    # source://roda//lib/roda/plugins.rb#39
    def register_plugin(name, mod); end

    def warn(*msgs, uplevel: T.unsafe(nil), category: T.unsafe(nil)); end
  end
end

# The base plugin for Roda, implementing all default functionality.
# Methods are put into a plugin so future plugins can easily override
# them and call super to get the default behavior.
#
# source://roda//lib/roda/request.rb#27
module Roda::RodaPlugins::Base; end

# Class methods for the Roda class.
#
# source://roda//lib/roda.rb#31
module Roda::RodaPlugins::Base::ClassMethods
  # The rack application that this class uses.
  #
  # source://roda//lib/roda.rb#33
  def app; end

  # Call the internal rack application with the given environment.
  # This allows the class itself to be used as a rack application.
  # However, for performance, it's better to use #app to get direct
  # access to the underlying rack app.
  #
  # source://roda//lib/roda.rb#52
  def call(env); end

  # Clear the middleware stack
  #
  # source://roda//lib/roda.rb#57
  def clear_middleware!; end

  # Define an instance method using the block with the provided name and
  # expected arity.  If the name is given as a Symbol, it is used directly.
  # If the name is given as a String, a unique name will be generated using
  # that string.  The expected arity should be either 0 (no arguments),
  # 1 (single argument), or :any (any number of arguments).
  #
  # If the :check_arity app option is not set to false, Roda will check that
  # the arity of the block matches the expected arity, and compensate for
  # cases where it does not.  If it is set to :warn, Roda will warn in the
  # cases where the arity does not match what is expected.
  #
  # If the expected arity is :any, Roda must perform a dynamic arity check
  # when the method is called, which can hurt performance even in the case
  # where the arity matches.  The :check_dynamic_arity app option can be
  # set to false to turn off the dynamic arity checks.  The
  # :check_dynamic_arity app option can be to :warn to warn if Roda needs
  # to adjust arity dynamically.
  #
  # Roda only checks arity for regular blocks, not lambda blocks, as the
  # fixes Roda uses for regular blocks would not work for lambda blocks.
  #
  # Roda does not support blocks with required keyword arguments if the
  # expected arity is 0 or 1.
  #
  # source://roda//lib/roda.rb#85
  def define_roda_method(meth, expected_arity, &block); end

  # Expand the given path, using the root argument as the base directory.
  #
  # source://roda//lib/roda.rb#179
  def expand_path(path, root = T.unsafe(nil)); end

  # Freeze the internal state of the class, to avoid thread safety issues at runtime.
  # It's optional to call this method, as nothing should be modifying the
  # internal state at runtime anyway, but this makes sure an exception will
  # be raised if you try to modify the internal state after calling this.
  #
  # Note that freezing the class prevents you from subclassing it, mostly because
  # it would cause some plugins to break.
  #
  # source://roda//lib/roda.rb#190
  def freeze; end

  # Rebuild the _roda_before and _roda_after methods whenever a plugin might
  # have added a _roda_before_* or _roda_after_* method.
  #
  # source://roda//lib/roda.rb#230
  def include(*a); end

  # Whether middleware from the current class should be inherited by subclasses.
  # True by default, should be set to false when using a design where the parent
  # class accepts requests and uses run to dispatch the request to a subclass.
  #
  # source://roda//lib/roda.rb#40
  def inherit_middleware; end

  # Whether middleware from the current class should be inherited by subclasses.
  # True by default, should be set to false when using a design where the parent
  # class accepts requests and uses run to dispatch the request to a subclass.
  #
  # source://roda//lib/roda.rb#40
  def inherit_middleware=(_arg0); end

  # When inheriting Roda, copy the shared data into the subclass,
  # and setup the request and response subclasses.
  #
  # @raise [RodaError]
  #
  # source://roda//lib/roda.rb#239
  def inherited(subclass); end

  # The settings/options hash for the current class.
  #
  # source://roda//lib/roda.rb#43
  def opts; end

  # Load a new plugin into the current class.  A plugin can be a module
  # which is used directly, or a symbol representing a registered plugin
  # which will be required and then used. Returns nil.
  #
  # Note that you should not load plugins into a Roda class after the
  # class has been subclassed, as doing so can break the subclasses.
  #
  #   Roda.plugin PluginModule
  #   Roda.plugin :csrf
  #
  # @raise [RodaError]
  #
  # source://roda//lib/roda.rb#279
  def plugin(plugin, *args, **_arg2, &block); end

  # Setup routing tree for the current Roda application, and build the
  # underlying rack application using the stored middleware. Requires
  # a block, which is yielded the request.  By convention, the block
  # argument should be named +r+.  Example:
  #
  #   Roda.route do |r|
  #     r.root do
  #       "Root"
  #     end
  #   end
  #
  # This should only be called once per class, and if called multiple
  # times will overwrite the previous routing.
  #
  # source://roda//lib/roda.rb#316
  def route(&block); end

  # The route block that this class uses.
  #
  # source://roda//lib/roda.rb#46
  def route_block; end

  # Add a middleware to use for the rack application.  Must be
  # called before calling #route to have an effect. Example:
  #
  #   Roda.use Rack::ShowExceptions
  #
  # source://roda//lib/roda.rb#333
  def use(*args, **_arg1, &block); end

  private

  # Return the number of required argument, optional arguments,
  # whether the callable accepts any additional arguments,
  # and whether the callable accepts keyword arguments (true, false
  # or :required).
  #
  # source://roda//lib/roda.rb#347
  def _define_roda_method_arg_numbers(callable); end

  # The base rack app to use, before middleware is added.
  #
  # source://roda//lib/roda.rb#378
  def base_rack_app_callable(new_api = T.unsafe(nil)); end

  # Build the rack app to use
  #
  # source://roda//lib/roda.rb#388
  def build_rack_app; end

  # Modify the route block to use for any route block provided as input,
  # which can include route blocks that are delegated to by the main route block.
  # Can be modified by plugins.
  #
  # source://roda//lib/roda.rb#403
  def convert_route_block(block); end

  # Build a _roda_after method that calls each _roda_after_* method
  # in order, if any _roda_after_* methods are defined. Also, use
  # the internal after hook plugin if the _roda_after method is defined.
  #
  # source://roda//lib/roda.rb#427
  def def_roda_after; end

  # Build a _roda_before method that calls each _roda_before_* method
  # in order, if any _roda_before_* methods are defined. Also, rebuild
  # the route block if a _roda_before method is defined.
  #
  # source://roda//lib/roda.rb#410
  def def_roda_before; end

  # The route block to use when building the rack app (or other initial
  # entry point to the route block).
  # By default, modifies the rack app route block to support before hooks
  # if any before hooks are defined.
  # Can be modified by plugins.
  #
  # source://roda//lib/roda.rb#446
  def rack_app_route_block(block); end

  # source://roda//lib/roda.rb#471
  def roda_method_name(suffix); end

  # Whether the new dispatch API should be used.
  #
  # @return [Boolean]
  #
  # source://roda//lib/roda.rb#451
  def use_new_dispatch_api?; end
end

# Instance methods for the Roda class.
#
# In addition to the listed methods, the following two methods are available:
#
# request :: The instance of the request class related to this request.
#            This is the same object yielded by Roda.route.
# response :: The instance of the response class related to this request.
#
# source://roda//lib/roda.rb#483
module Roda::RodaPlugins::Base::InstanceMethods
  # Create a request and response of the appropriate class
  #
  # source://roda//lib/roda.rb#485
  def initialize(env); end

  # Handle dispatching to the main route, catching :halt and handling
  # the result of the block.
  #
  # source://roda//lib/roda.rb#493
  def _roda_handle_main_route; end

  # Treat the given block as a routing block, catching :halt if
  # thrown by the block.
  #
  # source://roda//lib/roda.rb#503
  def _roda_handle_route; end

  # Default implementation of the main route, usually overridden
  # by Roda.route.
  #
  # source://roda//lib/roda.rb#512
  def _roda_main_route(_); end

  # Run the main route block with the request.  Designed for
  # extension by plugins
  #
  # source://roda//lib/roda.rb#517
  def _roda_run_main_route(r); end

  # Deprecated method for the previous main route dispatch API.
  #
  # source://roda//lib/roda.rb#522
  def call(&block); end

  # The environment hash for the current request. Example:
  #
  #   env['REQUEST_METHOD'] # => 'GET'
  #
  # source://roda//lib/roda.rb#539
  def env; end

  # The class-level options hash.  This should probably not be
  # modified at the instance level. Example:
  #
  #   Roda.plugin :render
  #   Roda.route do |r|
  #     opts[:render_opts].inspect
  #   end
  #
  # source://roda//lib/roda.rb#550
  def opts; end

  def request; end
  def response; end

  # The session hash for the current request. Raises RodaError
  # if no session exists. Example:
  #
  #   session # => {}
  #
  # source://roda//lib/roda.rb#566
  def session; end

  private

  # Deprecated method for the previous main route dispatch API.
  # Deprecated private alias for internal use
  #
  # source://roda//lib/roda.rb#522
  def _call(&block); end
end

# Class methods for RodaRequest
#
# source://roda//lib/roda/request.rb#29
module Roda::RodaPlugins::Base::RequestClassMethods
  # Return the cached pattern for the given object.  If the object is
  # not already cached, yield to get the basic pattern, and convert the
  # basic pattern to a pattern that does not match partial segments.
  #
  # source://roda//lib/roda/request.rb#39
  def cached_matcher(obj); end

  # Since RodaRequest is anonymously subclassed when Roda is subclassed,
  # and then assigned to a constant of the Roda subclass, make inspect
  # reflect the likely name for the class.
  #
  # source://roda//lib/roda/request.rb#52
  def inspect; end

  # The cache to use for match patterns for this request class.
  #
  # source://roda//lib/roda/request.rb#34
  def match_pattern_cache; end

  # The cache to use for match patterns for this request class.
  #
  # source://roda//lib/roda/request.rb#34
  def match_pattern_cache=(_arg0); end

  # Reference to the Roda class related to this request class.
  #
  # source://roda//lib/roda/request.rb#31
  def roda_class; end

  # Reference to the Roda class related to this request class.
  #
  # source://roda//lib/roda/request.rb#31
  def roda_class=(_arg0); end

  private

  # The pattern to use for consuming, based on the given argument.  The returned
  # pattern requires the path starts with a string and does not match partial
  # segments.
  #
  # source://roda//lib/roda/request.rb#61
  def consume_pattern(pattern); end
end

# Instance methods for RodaRequest, mostly related to handling routing
# for the request.
#
# source://roda//lib/roda/request.rb#68
module Roda::RodaPlugins::Base::RequestMethods
  # Store the roda instance and environment.
  #
  # source://roda//lib/roda/request.rb#84
  def initialize(scope, env); end

  # Handle match block return values.  By default, if a string is given
  # and the response is empty, use the string as the response body.
  #
  # source://roda//lib/roda/request.rb#93
  def block_result(result); end

  # The current captures for the request.  This gets modified as routing
  # occurs.
  #
  # source://roda//lib/roda/request.rb#77
  def captures; end

  # Match GET requests.  If no arguments are provided, matches all GET
  # requests, otherwise, matches only GET requests where the arguments
  # given fully consume the path.
  #
  # source://roda//lib/roda/request.rb#103
  def get(*args, &block); end

  # Immediately stop execution of the route block and return the given
  # rack response array of status, headers, and body.  If no argument
  # is given, uses the current response.
  #
  #   r.halt [200, {'Content-Type'=>'text/html'}, ['Hello World!']]
  #
  #   response.status = 200
  #   response['Content-Type'] = 'text/html'
  #   response.write 'Hello World!'
  #   r.halt
  #
  # source://roda//lib/roda/request.rb#117
  def halt(res = T.unsafe(nil)); end

  # What HTTP version the request was submitted with.
  #
  # source://roda//lib/roda/request.rb#140
  def http_version; end

  # Show information about current request, including request class,
  # request method and full path.
  #
  #   r.inspect
  #   # => '#<Roda::RodaRequest GET /foo/bar>'
  #
  # source://roda//lib/roda/request.rb#126
  def inspect; end

  # Does a terminal match on the current path, matching only if the arguments
  # have fully matched the path.  If it matches, the match block is
  # executed, and when the match block returns, the rack response is
  # returned.
  #
  #   r.remaining_path
  #   # => "/foo/bar"
  #
  #   r.is 'foo' do
  #     # does not match, as path isn't fully matched (/bar remaining)
  #   end
  #
  #   r.is 'foo/bar' do
  #     # matches as path is empty after matching
  #   end
  #
  # If no arguments are given, matches if the path is already fully matched.
  #
  #   r.on 'foo/bar' do
  #     r.is do
  #       # matches as path is already empty
  #     end
  #   end
  #
  # Note that this matches only if the path after matching the arguments
  # is empty, not if it still contains a trailing slash:
  #
  #   r.remaining_path
  #   # =>  "/foo/bar/"
  #
  #   r.is 'foo/bar' do
  #     # does not match, as path isn't fully matched (/ remaining)
  #   end
  #
  #   r.is 'foo/bar/' do
  #     # matches as path is empty after matching
  #   end
  #
  #   r.on 'foo/bar' do
  #     r.is "" do
  #       # matches as path is empty after matching
  #     end
  #   end
  #
  # source://roda//lib/roda/request.rb#192
  def is(*args, &block); end

  # Optimized method for whether this request is a +GET+ request.
  # Similar to the default Rack::Request get? method, but can be
  # overridden without changing rack's behavior.
  #
  # @return [Boolean]
  #
  # source://roda//lib/roda/request.rb#206
  def is_get?; end

  # The already matched part of the path, including the original SCRIPT_NAME.
  #
  # source://roda//lib/roda/request.rb#246
  def matched_path; end

  # Does a match on the path, matching only if the arguments
  # have matched the path.  Because this doesn't fully match the
  # path, this is usually used to setup branches of the routing tree,
  # not for final handling of the request.
  #
  #   r.remaining_path
  #   # => "/foo/bar"
  #
  #   r.on 'foo' do
  #     # matches, path is /bar after matching
  #   end
  #
  #   r.on 'bar' do
  #     # does not match
  #   end
  #
  # Like other routing methods, If it matches, the match block is
  # executed, and when the match block returns, the rack response is
  # returned.  However, in general you will call another routing method
  # inside the match block that fully matches the path and does the
  # final handling for the request:
  #
  #   r.on 'foo' do
  #     r.is 'bar' do
  #       # handle /foo/bar request
  #     end
  #   end
  #
  # source://roda//lib/roda/request.rb#237
  def on(*args, &block); end

  # This an an optimized version of Rack::Request#path.
  #
  #   r.env['SCRIPT_NAME'] = '/foo'
  #   r.env['PATH_INFO'] = '/bar'
  #   r.path
  #   # => '/foo/bar'
  #
  # source://roda//lib/roda/request.rb#257
  def path; end

  # Match POST requests.  If no arguments are provided, matches all POST
  # requests, otherwise, matches only POST requests where the arguments
  # given fully consume the path.
  #
  # source://roda//lib/roda/request.rb#272
  def post(*args, &block); end

  # The current path to match requests against.
  # An alias of remaining_path. If a plugin changes remaining_path then
  # it should override this method to return the untouched original.
  def real_remaining_path; end

  # Immediately redirect to the path using the status code.  This ends
  # the processing of the request:
  #
  #   r.redirect '/page1', 301 if r['param'] == 'value1'
  #   r.redirect '/page2' # uses 302 status code
  #   response.status = 404 # not reached
  #
  # If you do not provide a path, by default it will redirect to the same
  # path if the request is not a +GET+ request.  This is designed to make
  # it easy to use where a +POST+ request to a URL changes state, +GET+
  # returns the current state, and you want to show the current state
  # after changing:
  #
  #   r.is "foo" do
  #     r.get do
  #       # show state
  #     end
  #
  #     r.post do
  #       # change state
  #       r.redirect
  #     end
  #   end
  #
  # source://roda//lib/roda/request.rb#299
  def redirect(path = T.unsafe(nil), status = T.unsafe(nil)); end

  # The current path to match requests against.
  #
  # source://roda//lib/roda/request.rb#263
  def remaining_path; end

  # The response related to the current request.  See ResponseMethods for
  # instance methods for the response, but in general the most common usage
  # is to override the response status and headers:
  #
  #   response.status = 200
  #   response['Header-Name'] = 'Header value'
  #
  # source://roda//lib/roda/request.rb#310
  def response; end

  # Return the Roda class related to this request.
  #
  # source://roda//lib/roda/request.rb#315
  def roda_class; end

  # Match method that only matches +GET+ requests where the current
  # path is +/+.  If it matches, the match block is executed, and when
  # the match block returns, the rack response is returned.
  #
  #   [r.request_method, r.remaining_path]
  #   # => ['GET', '/']
  #
  #   r.root do
  #     # matches
  #   end
  #
  # This is usuable inside other match blocks:
  #
  #   [r.request_method, r.remaining_path]
  #   # => ['GET', '/foo/']
  #
  #   r.on 'foo' do
  #     r.root do
  #       # matches
  #     end
  #   end
  #
  # Note that this does not match non-+GET+ requests:
  #
  #   [r.request_method, r.remaining_path]
  #   # => ['POST', '/']
  #
  #   r.root do
  #     # does not match
  #   end
  #
  # Use <tt>r.post ""</tt> for +POST+ requests where the current path
  # is +/+.
  #
  # Nor does it match empty paths:
  #
  #   [r.request_method, r.remaining_path]
  #   # => ['GET', '/foo']
  #
  #   r.on 'foo' do
  #     r.root do
  #       # does not match
  #     end
  #   end
  #
  # Use <tt>r.get true</tt> to handle +GET+ requests where the current
  # path is empty.
  #
  # source://roda//lib/roda/request.rb#366
  def root(&block); end

  # Call the given rack app with the environment and return the response
  # from the rack app as the response for this request.  This ends
  # the processing of the request:
  #
  #   r.run(proc{[403, {}, []]}) unless r['letmein'] == '1'
  #   r.run(proc{[404, {}, []]})
  #   response.status = 404 # not reached
  #
  # This updates SCRIPT_NAME/PATH_INFO based on the current remaining_path
  # before dispatching to another rack app, so the app still works as
  # a URL mapper.
  #
  # source://roda//lib/roda/request.rb#383
  def run(app); end

  # The Roda instance related to this request object.  Useful if routing
  # methods need access to the scope of the Roda route block.
  #
  # source://roda//lib/roda/request.rb#81
  def scope; end

  # The session for the current request.  Raises a RodaError if
  # a session handler has not been loaded.
  #
  # source://roda//lib/roda/request.rb#402
  def session; end

  private

  # Match any of the elements in the given array.  Return at the
  # first match without evaluating future matches.  Returns false
  # if no elements in the array match.
  #
  # source://roda//lib/roda/request.rb#411
  def _match_array(matcher); end

  # Match the given class.  Currently, the following classes
  # are supported by default:
  # Integer :: Match an integer segment, yielding result to block as an integer
  # String :: Match any non-empty segment, yielding result to block as a string
  #
  # source://roda//lib/roda/request.rb#427
  def _match_class(klass); end

  # Match integer segment of up to 100 decimal characters, and yield resulting value as an
  # integer.
  #
  # source://roda//lib/roda/request.rb#445
  def _match_class_Integer; end

  # Match the given symbol if any segment matches.
  # Match any nonempty segment.  This should be called without an argument.
  #
  # source://roda//lib/roda/request.rb#502
  def _match_class_String(sym = T.unsafe(nil)); end

  # Convert the segment matched by the Integer matcher to an integer.
  #
  # source://roda//lib/roda/request.rb#454
  def _match_class_convert_Integer(value); end

  # Match the given hash if all hash matchers match.
  #
  # source://roda//lib/roda/request.rb#438
  def _match_hash(hash); end

  # Match only if all of the arguments in the given array match.
  # Match the given regexp exactly if it matches a full segment.
  #
  # source://roda//lib/roda/request.rb#460
  def _match_regexp(re); end

  # Match the given string to the request path.  Matches only if the
  # request path ends with the string or if the next character in the
  # request path is a slash (indicating a new segment).
  #
  # source://roda//lib/roda/request.rb#467
  def _match_string(str); end

  # Match the given symbol if any segment matches.
  #
  # source://roda//lib/roda/request.rb#502
  def _match_symbol(sym = T.unsafe(nil)); end

  # The base remaining path to use.
  #
  # source://roda//lib/roda/request.rb#519
  def _remaining_path(env); end

  # Backbone of the verb method support, using a terminal match if
  # args is not empty, or a regular match if it is empty.
  #
  # source://roda//lib/roda/request.rb#525
  def _verb(args, &block); end

  # Yield to the match block and return rack response after the block returns.
  #
  # source://roda//lib/roda/request.rb#535
  def always; end

  # The body to use for the response if the response does not already have
  # a body.  By default, a String is returned directly, and nil is
  # returned otherwise.
  #
  # source://roda//lib/roda/request.rb#543
  def block_result_body(result); end

  # Attempts to match the pattern to the current path.  If there is no
  # match, returns false without changes.  Otherwise, modifies
  # SCRIPT_NAME to include the matched path, removes the matched
  # path from PATH_INFO, and updates captures with any regex captures.
  #
  # source://roda//lib/roda/request.rb#558
  def consume(pattern); end

  # The default path to use for redirects when a path is not given.
  # For non-GET requests, redirects to the current path, which will
  # trigger a GET request.  This is to make the common case where
  # a POST request will redirect to a GET request at the same location
  # will work fine.
  #
  # If the current request is a GET request, raise an error, as otherwise
  # it is easy to create an infinite redirect.
  #
  # @raise [RodaError]
  #
  # source://roda//lib/roda/request.rb#577
  def default_redirect_path; end

  # The default status to use for redirects if a status is not provided,
  # 302 by default.
  #
  # source://roda//lib/roda/request.rb#584
  def default_redirect_status; end

  # Whether the current path is considered empty.
  #
  # @return [Boolean]
  #
  # source://roda//lib/roda/request.rb#589
  def empty_path?; end

  # If all of the arguments match, yields to the match block and
  # returns the rack response when the block returns.  If any of
  # the match arguments doesn't match, does nothing.
  #
  # source://roda//lib/roda/request.rb#596
  def if_match(args); end

  # Attempt to match the argument to the given request, handling
  # common ruby types.
  #
  # source://roda//lib/roda/request.rb#613
  def match(matcher); end

  # Match only if all of the arguments in the given array match.
  #
  # source://roda//lib/roda/request.rb#641
  def match_all(args); end

  # Match by request method.  This can be an array if you want
  # to match on multiple methods.
  #
  # source://roda//lib/roda/request.rb#647
  def match_method(type); end

  # How to handle block results that are not nil, false, or a String.
  # By default raises an exception.
  #
  # @raise [RodaError]
  #
  # source://roda//lib/roda/request.rb#657
  def unsupported_block_result(result); end

  # Handle an unsupported matcher.
  #
  # @raise [RodaError]
  #
  # source://roda//lib/roda/request.rb#662
  def unsupported_matcher(matcher); end
end

# source://roda//lib/roda/request.rb#69
Roda::RodaPlugins::Base::RequestMethods::TERM = T.let(T.unsafe(nil), Object)

# Class methods for RodaResponse
#
# source://roda//lib/roda/response.rb#19
module Roda::RodaPlugins::Base::ResponseClassMethods
  # Since RodaResponse is anonymously subclassed when Roda is subclassed,
  # and then assigned to a constant of the Roda subclass, make inspect
  # reflect the likely name for the class.
  #
  # source://roda//lib/roda/response.rb#26
  def inspect; end

  # Reference to the Roda class related to this response class.
  #
  # source://roda//lib/roda/response.rb#21
  def roda_class; end

  # Reference to the Roda class related to this response class.
  #
  # source://roda//lib/roda/response.rb#21
  def roda_class=(_arg0); end
end

# Instance methods for RodaResponse
#
# source://roda//lib/roda/response.rb#32
module Roda::RodaPlugins::Base::ResponseMethods
  # Set the default headers when creating a response.
  #
  # source://roda//lib/roda/response.rb#54
  def initialize; end

  # Return the response header with the given key. Example:
  #
  #   response['Content-Type'] # => 'text/html'
  #
  # source://roda//lib/roda/response.rb#64
  def [](key); end

  # Set the response header with the given key to the given value.
  #
  #   response['Content-Type'] = 'application/json'
  #
  # source://roda//lib/roda/response.rb#71
  def []=(key, value); end

  # The body for the current response.
  #
  # source://roda//lib/roda/response.rb#36
  def body; end

  # The default headers to use for responses.
  #
  # source://roda//lib/roda/response.rb#76
  def default_headers; end

  # Return the default response status to be used when the body
  # has been written to. This is split out to make overriding
  # easier in plugins.
  #
  # source://roda//lib/roda/response.rb#137
  def default_status; end

  # Whether the response body has been written to yet.  Note
  # that writing an empty string to the response body marks
  # the response as not empty. Example:
  #
  #   response.empty? # => true
  #   response.write('a')
  #   response.empty? # => false
  #
  # @return [Boolean]
  #
  # source://roda//lib/roda/response.rb#87
  def empty?; end

  # Return the rack response array of status, headers, and body
  # for the current response.  If the status has not been set,
  # uses the return value of default_status if the body has
  # been written to, otherwise uses a 404 status.
  # Adds the Content-Length header to the size of the response body.
  #
  # Example:
  #
  #   response.finish
  #   #  => [200,
  #   #      {'Content-Type'=>'text/html', 'Content-Length'=>'0'},
  #   #      []]
  #
  # source://roda//lib/roda/response.rb#103
  def finish; end

  # Return the rack response array using a given body.  Assumes a
  # 200 response status unless status has been explicitly set,
  # and doesn't add the Content-Length header or use the existing
  # body.
  #
  # source://roda//lib/roda/response.rb#129
  def finish_with_body(body); end

  # The hash of response headers for the current response.
  #
  # source://roda//lib/roda/response.rb#39
  def headers; end

  # Show response class, status code, response headers, and response body
  #
  # source://roda//lib/roda/response.rb#142
  def inspect; end

  # Set the Location header to the given path, and the status
  # to the given status.  Example:
  #
  #   response.redirect('foo', 301)
  #   response.redirect('bar')
  #
  # source://roda//lib/roda/response.rb#151
  def redirect(path, status = T.unsafe(nil)); end

  # Return the Roda class related to this response.
  #
  # source://roda//lib/roda/response.rb#158
  def roda_class; end

  # The status code to use for the response.  If none is given, will use 200
  # code for non-empty responses and a 404 code for empty responses.
  #
  # source://roda//lib/roda/response.rb#43
  def status; end

  # The status code to use for the response.  If none is given, will use 200
  # code for non-empty responses and a 404 code for empty responses.
  #
  # source://roda//lib/roda/response.rb#43
  def status=(_arg0); end

  # Write to the response body.  Returns nil.
  #
  #   response.write('foo')
  #
  # source://roda//lib/roda/response.rb#165
  def write(str); end

  private

  # Set the content length for empty 205 responses to 0
  #
  # source://roda//lib/roda/response.rb#183
  def empty_205_headers(headers); end

  # For each default header, if a header has not already been set for the
  # response, set the header in the response.
  #
  # source://roda//lib/roda/response.rb#191
  def set_default_headers; end
end

# source://roda//lib/roda/response.rb#33
Roda::RodaPlugins::Base::ResponseMethods::DEFAULT_HEADERS = T.let(T.unsafe(nil), Hash)

# source://roda//lib/roda/plugins.rb#10
Roda::RodaPlugins::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# The error_handler plugin adds an error handler to the routing,
# so that if routing the request raises an error, a nice error
# message page can be returned to the user.
#
# You can provide the error handler as a block to the plugin:
#
#   plugin :error_handler do |e|
#     "Oh No!"
#   end
#
# Or later via the +error+ class method:
#
#   plugin :error_handler
#
#   error do |e|
#     "Oh No!"
#   end
#
# In both cases, the exception instance is passed into the block,
# and the block can return the request body via a string.
#
# If an exception is raised, a new response will be used, with the
# default status set to 500, before executing the error handler.
# The error handler can change the response status if necessary,
# as well set headers and/or write to the body, just like a regular
# request.  After the error handler returns a response, normal after
# processing of that response occurs, except that an exception during
# after processing is logged to <tt>env['rack.errors']</tt> but
# otherwise ignored. This avoids recursive calls into the
# error_handler.  Note that if the error_handler itself raises
# an exception, the exception will be raised without normal after
# processing.  This can cause some after processing to run twice
# (once before the error_handler is called and once after) if
# later after processing raises an exception.
#
# By default, this plugin handles StandardError and ScriptError.
# To override the exception classes it will handle, pass a :classes
# option to the plugin:
#
#   plugin :error_handler, classes: [StandardError, ScriptError, NoMemoryError]
#
# source://roda//lib/roda/plugins/error_handler.rb#46
module Roda::RodaPlugins::ErrorHandler
  class << self
    # If a block is given, automatically call the +error+ method on
    # the Roda class with it.
    #
    # source://roda//lib/roda/plugins/error_handler.rb#51
    def configure(app, opts = T.unsafe(nil), &block); end
  end
end

# source://roda//lib/roda/plugins/error_handler.rb#59
module Roda::RodaPlugins::ErrorHandler::ClassMethods
  # Install the given block as the error handler, so that if routing
  # the request raises an exception, the block will be called with
  # the exception in the scope of the Roda instance.
  #
  # source://roda//lib/roda/plugins/error_handler.rb#63
  def error(&block); end
end

# source://roda//lib/roda/plugins/error_handler.rb#47
Roda::RodaPlugins::ErrorHandler::DEFAULT_ERROR_HANDLER_CLASSES = T.let(T.unsafe(nil), Array)

# source://roda//lib/roda/plugins/error_handler.rb#70
module Roda::RodaPlugins::ErrorHandler::InstanceMethods
  # If an error occurs, set the response status to 500 and call
  # the error handler.
  #
  # source://roda//lib/roda/plugins/error_handler.rb#86
  def _roda_handle_main_route; end

  # If an error occurs, set the response status to 500 and call
  # the error handler. Old Dispatch API.
  #
  # source://roda//lib/roda/plugins/error_handler.rb#73
  def call; end

  private

  # Handle the given exception using handle_error, using a default status
  # of 500.  Run after hooks on the rack response, but if any error occurs
  # when doing so, log the error using rack.errors and return the response.
  #
  # source://roda//lib/roda/plugins/error_handler.rb#106
  def _handle_error(e); end

  # Default empty implementation of _roda_after, usually
  # overridden by Roda.def_roda_before.
  #
  # source://roda//lib/roda/plugins/error_handler.rb#100
  def _roda_after(res); end

  # By default, have the error handler reraise the error, so using
  # the plugin without installing an error handler doesn't change
  # behavior.
  #
  # source://roda//lib/roda/plugins/error_handler.rb#125
  def handle_error(e); end
end

# The flash plugin adds a +flash+ instance method to Roda,
# for typical web application flash handling, where values
# set in the current flash hash are available in the next
# request.
#
# With the example below, if a POST request is submitted,
# it will redirect and the resulting GET request will
# return 'b'.
#
#   plugin :flash
#
#   route do |r|
#     r.is '' do
#       r.get do
#         flash['a']
#       end
#
#       r.post do
#         flash['a'] = 'b'
#         r.redirect('')
#       end
#     end
#   end
#
# You can modify the flash for the current request (instead of
# the next request) by using the +flash.now+ method:
#
#   r.get do
#     flash.now['a'] = 'b'
#     flash['a'] # = >'b'
#   end
#
# source://roda//lib/roda/plugins/flash.rb#38
module Roda::RodaPlugins::Flash; end

# Simple flash hash, where assiging to the hash updates the flash
# used in the following request.
#
# source://roda//lib/roda/plugins/flash.rb#43
class Roda::RodaPlugins::Flash::FlashHash
  # Setup the next hash when initializing, and handle treat nil
  # as a new empty hash.
  #
  # @return [FlashHash] a new instance of FlashHash
  #
  # source://roda//lib/roda/plugins/flash.rb#51
  def initialize(hash = T.unsafe(nil)); end

  # Update the next hash with the given key and value.
  #
  # source://roda//lib/roda/plugins/flash.rb#57
  def []=(k, v); end

  # Remove given key from the next hash, or clear the next hash if
  # no argument is given.
  #
  # source://roda//lib/roda/plugins/flash.rb#63
  def discard(key = T.unsafe(nil)); end

  # Copy the entry with the given key from the current hash to the
  # next hash, or copy all entries from the current hash to the
  # next hash if no argument is given.
  #
  # source://roda//lib/roda/plugins/flash.rb#74
  def keep(key = T.unsafe(nil)); end

  # The flash hash for the next request.  This
  # is what gets written to by #[]=.
  #
  # source://roda//lib/roda/plugins/flash.rb#44
  def next; end

  # The flash hash for the current request
  #
  # source://delegate/0.2.0/delegate.rb#402
  def now; end

  # Replace the current hash with the next hash and clear the next hash.
  #
  # source://roda//lib/roda/plugins/flash.rb#83
  def sweep; end
end

# source://roda//lib/roda/plugins/flash.rb#90
module Roda::RodaPlugins::Flash::InstanceMethods
  # Access the flash hash for the current request, loading
  # it from the session if it is not already loaded.
  #
  # source://roda//lib/roda/plugins/flash.rb#93
  def flash; end

  private

  # If the routing doesn't raise an error, rotate the flash
  # hash in the session so the next request has access to it.
  #
  # source://roda//lib/roda/plugins/flash.rb#102
  def _roda_after_40__flash(_); end
end

# The not_found plugin adds a +not_found+ class method which sets
# a block that is called whenever a 404 response with an empty body
# would be returned.  The usual use case for this is the desire for
# nice error pages if the page is not found.
#
# You can provide the block with the plugin call:
#
#   plugin :not_found do
#     "Where did it go?"
#   end
#
# Or later via a separate call to +not_found+:
#
#   plugin :not_found
#
#   not_found do
#     "Where did it go?"
#   end
#
# Before not_found is called, any existing headers on the response
# will be cleared.  So if you want to be sure the headers are set
# even in a not_found block, you need to reset them in the
# not_found block.
#
# This plugin is now a wrapper around the +status_handler+ plugin and
# still exists mainly for backward compatibility.
#
# source://roda//lib/roda/plugins/not_found.rb#32
module Roda::RodaPlugins::NotFound
  class << self
    # If a block is given, install the block as the not_found handler.
    #
    # source://roda//lib/roda/plugins/not_found.rb#39
    def configure(app, &block); end

    # Require the status_handler plugin
    #
    # source://roda//lib/roda/plugins/not_found.rb#34
    def load_dependencies(app); end
  end
end

# source://roda//lib/roda/plugins/not_found.rb#45
module Roda::RodaPlugins::NotFound::ClassMethods
  # Install the given block as the not_found handler.
  #
  # source://roda//lib/roda/plugins/not_found.rb#47
  def not_found(&block); end
end

# source://roda//lib/roda/plugins.rb#9
Roda::RodaPlugins::OPTS = T.let(T.unsafe(nil), Hash)

# The render plugin adds support for template rendering using the tilt
# library.  Two methods are provided for template rendering, +view+
# (which uses the layout) and +render+ (which does not).
#
#   plugin :render
#
#   route do |r|
#     r.is 'foo' do
#       view('foo') # renders views/foo.erb inside views/layout.erb
#     end
#
#     r.is 'bar' do
#       render('bar') # renders views/bar.erb
#     end
#   end
#
# The +render+ and +view+ methods just return strings, they do not have
# side effects (unless the templates themselves have side effects).
# As Roda uses the routing block return value as the body of the response,
# in most cases you will call these methods as the last expression in a
# routing block to have the response body be the result of the template
# rendering.
#
# Because +render+ and +view+ just return strings, you can call them inside
# templates (i.e. for subtemplates/partials), or multiple times in the
# same route and combine the results together:
#
#   route do |r|
#     r.is 'foo-bars' do
#       @bars = Bar.where(:foo).map{|b| render(:bar, locals: {bar: b})}.join
#       view('foo')
#     end
#   end
#
# You can provide options to the plugin method:
#
#   plugin :render, engine: 'haml', views: 'admin_views'
#
# = Plugin Options
#
# The following plugin options are supported:
#
# :allowed_paths :: Set the template paths to allow.  Attempts to render paths outside
#                   of these paths will raise an error.  Defaults to the +:views+ directory.
# :cache :: nil/false to explicitly disable premanent template caching.  By default, permanent
#           template caching is disabled by default if RACK_ENV is development.  When permanent
#           template caching is disabled, for templates with paths in the file system, the
#           modification time of the file will be checked on every render, and if it has changed,
#           a new template will be created for the current content of the file.
# :cache_class :: A class to use as the template cache instead of the default.
# :check_paths :: Can be set to false to turn off template path checking.
# :engine :: The tilt engine to use for rendering, also the default file extension for
#            templates, defaults to 'erb'.
# :escape :: Use Erubi as the ERB template engine, and enable escaping by default,
#            which makes <tt><%= %></tt> escape output and  <tt><%== %></tt> not escape output.
#            If given, sets the <tt>escape: true</tt> option for all template engines, which
#            can break some non-ERB template engines.  You can use a string or array of strings
#            as the value for this option to only set the <tt>escape: true</tt> option for those
#            specific template engines.
# :layout :: The base name of the layout file, defaults to 'layout'.  This can be provided as a hash
#            with the :template or :inline options.
# :layout_opts :: The options to use when rendering the layout, if different from the default options.
# :template_opts :: The tilt options used when rendering all templates. defaults to:
# :engine_opts :: The tilt options to use per template engine.  Keys are
#                 engine strings, values are hashes of template options.
# :views :: The directory holding the view files, defaults to the 'views' subdirectory of the
#           application's :root option (the process's working directory by default).
#
# = Render/View Method Options
#
# Most of these options can be overridden at runtime by passing options
# to the +view+ or +render+ methods:
#
#   view('foo', engine: 'html.erb')
#   render('foo', views: 'admin_views')
#
# There are additional options to +view+ and +render+ that are
# available at runtime:
#
# :cache :: Set to false to not cache this template, even when
#           caching is on by default.  Set to true to force caching for
#           this template, even when the default is to not permantently cache (e.g.
#           when using the :template_block option).
# :cache_key :: Explicitly set the hash key to use when caching.
# :content :: Only respected by +view+, provides the content to render
#             inside the layout, instead of rendering a template to get
#             the content.
# :inline :: Use the value given as the template code, instead of looking
#            for template code in a file.
# :locals :: Hash of local variables to make available inside the template.
# :path :: Use the value given as the full pathname for the file, instead
#          of using the :views and :engine option in combination with the
#          template name.
# :scope :: The object in which context to evaluate the template.  By
#           default, this is the Roda instance.
# :template :: Provides the name of the template to use.  This allows you
#              pass a single options hash to the render/view method, while
#              still allowing you to specify the template name.
# :template_block :: Pass this block when creating the underlying template,
#                    ignored when using :inline.  Disables caching of the
#                    template by default.
# :template_class :: Provides the template class to use, instead of using
#                    Tilt or <tt>Tilt[:engine]</tt>.
#
# Here's an example of using these options:
#
#   view(inline: '<%= @foo %>')
#   render(path: '/path/to/template.erb')
#
# If you pass a hash as the first argument to +view+ or +render+, it should
# have either +:template+, +:inline+, +:path+, or +:content+ (for +view+) as
# one of the keys.
#
# = Speeding Up Template Rendering
#
# The render/view method calls are optimized for usage with a single symbol/string
# argument specifying the template name.  So for fastest rendering, pass only a
# symbol/string to render/view.  Next best optimized are template calls with a
# single :locals option.  Use of other options disables the compiled template
# method optimizations and can be significantly slower.
#
# If you must pass a hash to render/view, either as a second argument or as the
# only argument, you can speed things up by specifying a +:cache_key+ option in
# the hash, making sure the +:cache_key+ is unique to the template you are
# rendering.
#
# = Accepting Template Blocks in Methods
#
# If you are used to Rails, you may be surprised that this type of template code
# doesn't work in Roda:
#
#   <%= some_method do %>
#     Some HTML
#   <% end %>
#
# The reason this doesn't work is that this is not valid ERB syntax, it is Rails syntax,
# and requires attempting to parse the <tt>some_method do</tt> Ruby code with a regular
# expression.  Since Roda uses ERB syntax, it does not support this.
#
# In general, these methods are used to wrap the content of the block and
# inject the content into the output. To get similar behavior with Roda, you have
# a few different options you can use.
#
# == Directly Inject Template Output
#
# You can switch from a <tt><%=</tt> tag to using a <tt><%</tt> tag:
#
#   <% some_method do %>
#     Some HTML
#   <% end %>
#
# While this would output <tt>Some HTML</tt> into the template, it would not be able
# to inject content before or after the block.  However, you can use the inject_erb_plugin
# to handle the injection:
#
#   def some_method
#     inject_erb "content before block"
#     yield
#     inject_erb "content after block"
#   end
#
# If you need to modify the captured block before injecting it, you can use the
# capture_erb plugin to capture content from the template block, and modify that content,
# then use inject_erb to inject it into the template output:
#
#   def some_method(&block)
#     inject_erb "content before block"
#     inject_erb capture_erb(&block).upcase
#     inject_erb "content after block"
#   end
#
# This is the recommended approach for handling this type of method, if you want to keep
# the template block in the same template.
#
# == Separate Block Output Into Separate Template
#
# By moving the <tt>Some HTML</tt> into a separate template, you can render that
# template inside the block:
#
#  <%= some_method{render('template_name')} %>
#
# It's also possible to use an inline template:
#
#   <%= some_method do render(:inline=><<-END)
#     Some HTML
#     END
#   end %>
#
# This approach is useful if it makes sense to separate the template block into its
# own template. You lose the ability to use local variable from outside the
# template block inside the template block with this approach.
#
# == Separate Header and Footer
#
# You can define two separate methods, one that outputs the content before the block,
# and one that outputs the content after the block, and use those instead of a single
# call:
#
#   <%= some_method_before %>
#     Some HTML
#   <%= some_method_after %>
#
# This is the simplest option to setup, but it is fairly tedious to use.
#
# source://roda//lib/roda/plugins/render.rb#211
module Roda::RodaPlugins::Render
  class << self
    # Setup default rendering options.  See Render for details.
    #
    # source://roda//lib/roda/plugins/render.rb#232
    def configure(app, opts = T.unsafe(nil)); end

    # :nocov:
    #
    # source://roda//lib/roda/plugins/render.rb#220
    def tilt_template_compiled_method(template, locals_keys, scope_class); end
  end
end

# source://roda//lib/roda/plugins/render.rb#217
Roda::RodaPlugins::Render::COMPILED_METHOD_SUPPORT = T.let(T.unsafe(nil), TrueClass)

# source://roda//lib/roda/plugins/render.rb#422
module Roda::RodaPlugins::Render::ClassMethods
  # Return an Tilt::Template object based on the given opts and template_opts.
  #
  # source://roda//lib/roda/plugins/render.rb#441
  def create_template(opts, template_opts); end

  # If using compiled methods and there is an optimized layout, speed up
  # access to the layout method to improve the performance of view.
  #
  # source://roda//lib/roda/plugins/render.rb#426
  def freeze; end

  # Copy the rendering options into the subclass, duping
  # them as necessary to prevent changes in the subclass
  # affecting the parent class.
  #
  # source://roda//lib/roda/plugins/render.rb#454
  def inherited(subclass); end

  # A proc that returns content, used for inline templates, so that the template
  # doesn't hold a reference to the instance of the class
  #
  # source://roda//lib/roda/plugins/render.rb#447
  def inline_template_block(content); end

  # Return the render options for this class.
  #
  # source://roda//lib/roda/plugins/render.rb#465
  def render_opts; end

  private

  # Precompile the layout method, to reduce method calls to look it up at runtime.
  #
  # source://roda//lib/roda/plugins/render.rb#472
  def _freeze_layout_method; end
end

# source://roda//lib/roda/plugins/render.rb#491
module Roda::RodaPlugins::Render::InstanceMethods
  # Render the given template. See Render for details.
  #
  # source://roda//lib/roda/plugins/render.rb#493
  def render(template, opts = T.unsafe(nil), &block); end

  # Return the render options for the instance's class.
  #
  # source://roda//lib/roda/plugins/render.rb#505
  def render_opts; end

  # Render the given template. See Render for details.
  # Private alias for render.  Should be used by other plugins when they want to render a template
  # without a layout, as plugins can override render to use a layout.
  #
  # source://roda//lib/roda/plugins/render.rb#493
  def render_template(template, opts = T.unsafe(nil), &block); end

  # Render the given template.  If there is a default layout
  # for the class, take the result of the template rendering
  # and render it inside the layout.  Blocks passed to view
  # are passed to render when rendering the template.
  # See Render for details.
  #
  # source://roda//lib/roda/plugins/render.rb#514
  def view(template, opts = T.unsafe(nil), &block); end

  private

  # If there is an instance method for the template, return the instance
  # method symbol.  This optimization is only used for render/view calls
  # with a single string or symbol argument.
  #
  # source://roda//lib/roda/plugins/render.rb#550
  def _cached_template_method(template); end

  # The key to use in the template method cache for the given template.
  #
  # source://roda//lib/roda/plugins/render.rb#560
  def _cached_template_method_key(template); end

  # Return the instance method symbol for the template in the method cache.
  #
  # source://roda//lib/roda/plugins/render.rb#565
  def _cached_template_method_lookup(method_cache, template); end

  # Return a symbol containing the optimized layout method
  #
  # source://roda//lib/roda/plugins/render.rb#570
  def _layout_method; end

  # Use an optimized render path for templates with a hash of locals.  Returns the result
  # of the template render if the optimized path is used, or nil if the optimized
  # path is not used and the long method needs to be used.
  #
  # source://roda//lib/roda/plugins/render.rb#577
  def _optimized_render_method_for_locals(template, locals); end

  # Get the content for #view, or return nil to use the unoptimized approach. Only called if
  # a single argument is passed to view.
  #
  # source://roda//lib/roda/plugins/render.rb#618
  def _optimized_view_content(template); end

  # If caching templates, attempt to retrieve the template from the cache.  Otherwise, just yield
  # to get the template.
  #
  # source://roda//lib/roda/plugins/render.rb#659
  def cached_template(opts, &block); end

  # Given the template name and options, set the template class, template path/content,
  # template block, and locals to use for the render in the passed options.
  #
  # source://roda//lib/roda/plugins/render.rb#673
  def find_template(opts); end

  # Return a single hash combining the template and opts arguments.
  #
  # source://roda//lib/roda/plugins/render.rb#711
  def parse_template_opts(template, opts); end

  # The default render options to use.  These set defaults that can be overridden by
  # providing a :layout_opts option to the view/render method.
  #
  # source://roda//lib/roda/plugins/render.rb#726
  def render_layout_opts; end

  # Convert template options to single hash when rendering templates using render.
  #
  # source://roda//lib/roda/plugins/render.rb#649
  def render_template_opts(template, opts); end

  # Retrieve the Tilt::Template object for the given template and opts.
  #
  # source://roda//lib/roda/plugins/render.rb#731
  def retrieve_template(opts); end

  # The name to use for the template.  By default, just converts the :template option to a string.
  #
  # source://roda//lib/roda/plugins/render.rb#782
  def template_name(opts); end

  # The template path for the given options.
  #
  # source://roda//lib/roda/plugins/render.rb#787
  def template_path(opts); end

  # If a layout should be used, return a hash of options for
  # rendering the layout template.  If a layout should not be
  # used, return nil.
  #
  # source://roda//lib/roda/plugins/render.rb#801
  def view_layout_opts(opts); end
end

# source://roda//lib/roda/plugins/render.rb#216
Roda::RodaPlugins::Render::NO_CACHE = T.let(T.unsafe(nil), Hash)

# Wrapper object for the Tilt template, that checks the modified
# time of the template file, and rebuilds the template if the
# template file has been modified.  This is an internal class and
# the API is subject to change at any time.
#
# source://roda//lib/roda/plugins/render.rb#322
class Roda::RodaPlugins::Render::TemplateMtimeWrapper
  # @return [TemplateMtimeWrapper] a new instance of TemplateMtimeWrapper
  #
  # source://roda//lib/roda/plugins/render.rb#323
  def initialize(roda_class, opts, template_opts); end

  # Compile a method in the given module with the given name that will
  # call the compiled template method, updating the compiled template method
  #
  # source://roda//lib/roda/plugins/render.rb#374
  def define_compiled_method(roda_class, method_name, locals_keys = T.unsafe(nil)); end

  # If the template file has been updated, return true and update
  # the template object and the modification time. Other return false.
  #
  # @return [Boolean]
  #
  # source://roda//lib/roda/plugins/render.rb#355
  def modified?; end

  # If the template file exists and the modification time has
  # changed, rebuild the template file, then call render on it.
  #
  # source://roda//lib/roda/plugins/render.rb#337
  def render(*args, &block); end

  # Return when the template was last modified.  If the template depends on any
  # other files, check the modification times of all dependencies and
  # return the maximum.
  #
  # source://roda//lib/roda/plugins/render.rb#345
  def template_last_modified; end

  private

  # Return the compiled method for the current template object.
  #
  # source://roda//lib/roda/plugins/render.rb#393
  def compiled_method(locals_keys = T.unsafe(nil), roda_class = T.unsafe(nil)); end

  # Return the lambda used to define the compiled template method.  This
  # is separated into its own method so the lambda does not capture any
  # unnecessary local variables
  #
  # source://roda//lib/roda/plugins/render.rb#400
  def compiled_method_lambda(template, roda_class, method_name, locals_keys = T.unsafe(nil)); end

  # Reset the template, done every time the template or one of its
  # dependencies is modified.
  #
  # source://roda//lib/roda/plugins/render.rb#417
  def reset_template; end
end

# The sessions plugin adds support for sessions using cookies. It is the recommended
# way to support sessions in Roda applications.
#
# The session cookies are encrypted with AES-256-CTR using a separate encryption key per cookie,
# and then signed with HMAC-SHA-256.  By default, session data is padded to reduce information
# leaked based on the session size.
#
# Sessions are serialized via JSON, so session information should only store data that
# allows roundtrips via JSON (String, Integer, Float, Array, Hash, true, false, and nil).
# In particular, note that Symbol does not round trip via JSON, so symbols should not be
# used in sessions when this plugin is used.  This plugin sets the
# +:sessions_convert_symbols+ application option to +true+ if it hasn't been set yet,
# for better integration with plugins that can use either symbol or string session or
# flash keys.  Unlike Rack::Session::Cookie, the session is stored as a plain ruby hash,
# and does not convert all keys to strings.
#
# All sessions are timestamped and session expiration is enabled by default, with sessions
# being valid for 30 days maximum and 7 days since last use by default.  Session creation time is
# reset whenever the session is empty when serialized and also whenever +clear_session+
# is called while processing the request.
#
# Session secrets can be rotated.  See options below.
#
# The sessions plugin can transparently upgrade sessions from Rack::Session::Cookie
# if the default Rack::Session::Cookie coder and HMAC are used, see options below.
# It is recommended to only enable transparent upgrades for a brief transition period,
# and remove support for them once old sessions have converted or timed out.
#
# If the final cookie is too large (>=4096 bytes), a Roda::RodaPlugins::Sessions::CookieTooLarge
# exception will be raised.
#
# = Required Options
#
# The session cookies this plugin uses are both encrypted and signed, so two separate
# secrets are used internally.  However, for ease of use, these secrets are combined into
# a single +:secret+ option.  The +:secret+ option must be a string of at least 64 bytes
# and should be randomly generated.  The first 32 bytes are used as the secret for the
# cipher, any remaining bytes are used for the secret for the HMAC.
#
# = Other Options
#
# :cookie_options :: Any cookie options to set on the session cookie. By default, uses
#                    <tt>httponly: true, path: '/', same_site: :lax</tt> so that the cookie is not accessible
#                    to javascript, allowed for all paths, and will not be used for cross-site non-GET requests
#                    that.  If the +:secure+ option is not present in the hash, then
#                    <tt>secure: true</tt> is also set if the request is made over HTTPS.  If this option is
#                    given, it will be merged into the default cookie options.
# :gzip_over :: For session data over this many bytes, compress it with the deflate algorithm (default: nil,
#               so never compress).  Note that compression should not be enabled if you are storing data in
#               the session derived from user input and also storing sensitive data in the session.
# :key :: The cookie name to use (default: <tt>'roda.session'</tt>)
# :max_seconds :: The maximum number of seconds to allow for total session lifetime, starting with when
#                 the session was originally created.  Default is <tt>86400*30</tt> (30 days). Can be set to
#                 +nil+ to disable session lifetime checks.
# :max_idle_seconds :: The maximum number of seconds to allow since the session was last updated.
#                      Default is <tt>86400*7</tt> (7 days).  Can be set to nil to disable session idleness
#                      checks.
# :old_secret :: The previous secret to use, allowing for secret rotation.  Must be a string of at least 64
#                bytes if given.
# :pad_size :: Pad session data (after possible compression, before encryption), to a multiple of this
#              many bytes (default: 32).  This can be between 2-4096 bytes, or +nil+ to disable padding.
# :per_cookie_cipher_secret :: Uses a separate cipher key for every cookie, with the key used generated using
#                              HMAC-SHA-256 of 32 bytes of random data with the default cipher secret. This
#                              offers additional protection in case the random initialization vector used when
#                              encrypting the session data has been reused. Odds of that are 1 in 2**64 if
#                              initialization vector is truly random, but weaknesses in the random number
#                              generator could make the odds much higher.  Default is +true+.
# :parser :: The parser for the serialized session data (default: <tt>JSON.method(:parse)</tt>).
# :serializer :: The serializer for the session data (default +:to_json.to_proc+).
# :skip_within :: If the last update time for the session cookie is less than this number of seconds from the
#                 current time, and the session has not been modified, do not set a new session cookie
#                 (default: 3600).
# :upgrade_from_rack_session_cookie_key :: The cookie name to use for transparently upgrading from
#                                          Rack::Session:Cookie (defaults to <tt>'rack.session'</tt>).
# :upgrade_from_rack_session_cookie_secret :: The secret for the HMAC-SHA1 signature when allowing
#                                             transparent upgrades from Rack::Session::Cookie. Using this
#                                             option is only recommended during a short transition period,
#                                             and is not enabled by default as it lowers security.
# :upgrade_from_rack_session_cookie_options :: Options to pass when deleting the cookie used by
#                                              Rack::Session::Cookie after converting it to use the session
#                                              cookies used by this plugin.
#
# = Not a Rack Middleware
#
# Unlike some other approaches to sessions, the sessions plugin does not use
# a rack middleware, so session information is not available to other rack middleware,
# only to the application itself, with the session not being loaded from the cookie
# until the +session+ method is called.
#
# If you need rack middleware to access the session information, then
# <tt>require 'roda/session_middleware'</tt> and <tt>use RodaSessionMiddleware</tt>.
# <tt>RodaSessionMiddleware</tt> passes the options given to this plugin.
#
# = Session Cookie Cryptography/Format
#
# Session cookies created by this plugin by default use the following format:
#
#   urlsafe_base64("\1" + random_data + IV + encrypted session data + HMAC)
#
# If +:per_cookie_cipher_secret+ option is set to +false+, an older format is used:
#
#   urlsafe_base64("\0" + IV + encrypted session data + HMAC)
#
# where:
#
# version :: 1 byte, currently must be 1 or 0, other values reserved for future expansion.
# random_data :: 32 bytes, used for generating the per-cookie secret
# IV :: 16 bytes, initialization vector for AES-256-CTR cipher.
# encrypted session data :: >=12 bytes of data encrypted with AES-256-CTR cipher, see below.
# HMAC :: 32 bytes, HMAC-SHA-256 of all preceding data plus cookie key (so that a cookie value
#         for a different key cannot be used even if the secret is the same).
#
# The encrypted session data uses the following format:
#
#   bitmap + creation time + update time + padding + serialized data
#
# where:
#
# bitmap :: 2 bytes in little endian format, lower 12 bits storing number of padding
#           bytes, 13th bit storing whether serialized data is compressed with deflate.
#           Bits 14-16 reserved for future expansion.
# creation time :: 4 byte integer in unsigned little endian format, storing unix timestamp
#                  since session initially created.
# update time :: 4 byte integer in unsigned little endian format, storing unix timestamp
#                since session last updated.
# padding :: >=0 padding bytes specified in bitmap, filled with random data, can be ignored.
# serialized data :: >=2 bytes of serialized data in JSON format.  If the bitmap indicates
#                    deflate compression, this contains the deflate compressed data.
#
# source://roda//lib/roda/plugins/sessions.rb#149
module Roda::RodaPlugins::Sessions
  class << self
    # Configure the plugin, see Sessions for details on options.
    #
    # source://roda//lib/roda/plugins/sessions.rb#175
    def configure(app, opts = T.unsafe(nil)); end

    # Split given secret into a cipher secret and an hmac secret.
    #
    # @raise [RodaError]
    #
    # source://roda//lib/roda/plugins/sessions.rb#166
    def split_secret(name, secret); end
  end
end

# Exception class used when creating a session cookie that would exceed the
# allowable cookie size limit.
#
# source://roda//lib/roda/plugins/sessions.rb#162
class Roda::RodaPlugins::Sessions::CookieTooLarge < ::Roda::RodaError; end

# source://roda//lib/roda/plugins/sessions.rb#150
Roda::RodaPlugins::Sessions::DEFAULT_COOKIE_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://roda//lib/roda/plugins/sessions.rb#151
Roda::RodaPlugins::Sessions::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://roda//lib/roda/plugins/sessions.rb#152
Roda::RodaPlugins::Sessions::DEFLATE_BIT = T.let(T.unsafe(nil), Integer)

# source://roda//lib/roda/plugins/sessions.rb#208
module Roda::RodaPlugins::Sessions::InstanceMethods
  # Clear data from the session, and update the request environment
  # so that the session cookie will use a new creation timestamp
  # instead of the previous creation timestamp.
  #
  # source://roda//lib/roda/plugins/sessions.rb#212
  def clear_session; end

  private

  # If session information has been set in the request environment,
  # update the rack response headers to set the session cookie in
  # the response.
  #
  # source://roda//lib/roda/plugins/sessions.rb#224
  def _roda_after_50__sessions(res); end
end

# source://roda//lib/roda/plugins/sessions.rb#153
Roda::RodaPlugins::Sessions::PADDING_MASK = T.let(T.unsafe(nil), Integer)

# source://roda//lib/roda/plugins/sessions.rb#231
module Roda::RodaPlugins::Sessions::RequestMethods
  # Persist the session data as a cookie.  If transparently upgrading from
  # Rack::Session::Cookie, mark the related cookie for expiration so it isn't
  # sent in the future.
  #
  # source://roda//lib/roda/plugins/sessions.rb#257
  def persist_session(headers, session); end

  # Load the session information from the cookie.  With the sessions
  # plugin, you must call this method to get the session, instead of
  # trying to access the session directly through the request environment.
  # For maximum compatibility with other software that uses rack sessions,
  # this method stores the session in 'rack.session' in the request environment,
  # but that does not happen until this method is called.
  #
  # source://roda//lib/roda/plugins/sessions.rb#238
  def session; end

  # The time the session was originally created. nil if there is no active session.
  #
  # source://roda//lib/roda/plugins/sessions.rb#243
  def session_created_at; end

  # The time the session was last updated. nil if there is no active session.
  #
  # source://roda//lib/roda/plugins/sessions.rb#249
  def session_updated_at; end

  private

  # Interpret given cookie data as a Rack::Session::Cookie
  # serialized session using the default Rack::Session::Cookie
  # hmac and coder.
  #
  # source://roda//lib/roda/plugins/sessions.rb#309
  def _deserialize_rack_session(data); end

  # Interpret given cookie data as a Rack::Session::Cookie
  #
  # source://roda//lib/roda/plugins/sessions.rb#343
  def _deserialize_session(data); end

  # Load the session by looking for the appropriate cookie, or falling
  # back to the rack session cookie if configured.
  #
  # source://roda//lib/roda/plugins/sessions.rb#286
  def _load_session; end

  # source://roda//lib/roda/plugins/sessions.rb#435
  def _serialize_session(session); end

  # If 'rack.errors' is set, write the error message to it.
  # This is used for errors that shouldn't be raised as exceptions,
  # such as improper session cookies.
  #
  # source://roda//lib/roda/plugins/sessions.rb#300
  def _session_serialization_error(msg); end
end

# source://roda//lib/roda/plugins/sessions.rb#154
Roda::RodaPlugins::Sessions::SESSION_CREATED_AT = T.let(T.unsafe(nil), String)

# source://roda//lib/roda/plugins/sessions.rb#158
Roda::RodaPlugins::Sessions::SESSION_DELETE_RACK_COOKIE = T.let(T.unsafe(nil), String)

# source://roda//lib/roda/plugins/sessions.rb#156
Roda::RodaPlugins::Sessions::SESSION_SERIALIZED = T.let(T.unsafe(nil), String)

# source://roda//lib/roda/plugins/sessions.rb#155
Roda::RodaPlugins::Sessions::SESSION_UPDATED_AT = T.let(T.unsafe(nil), String)

# source://roda//lib/roda/plugins/sessions.rb#157
Roda::RodaPlugins::Sessions::SESSION_VERSION_NUM = T.let(T.unsafe(nil), String)

# The status_handler plugin adds a +status_handler+ method which sets a
# block that is called whenever a response with the relevant response code
# with an empty body would be returned.
#
# This plugin does not support providing the blocks with the plugin call;
# you must provide them to status_handler calls afterwards:
#
#   plugin :status_handler
#
#   status_handler(403) do
#     "You are forbidden from seeing that!"
#   end
#
#   status_handler(404) do
#     "Where did it go?"
#   end
#
#   status_handler(405, keep_headers: ['Accept']) do
#     "Use a different method!"
#   end
#
# Before a block is called, any existing headers on the response will be
# cleared, unless the +:keep_headers+ option is used.  If the +:keep_headers+
# option is used, the value should be an array, and only the headers listed
# in the array will be kept.
#
# source://roda//lib/roda/plugins/status_handler.rb#31
module Roda::RodaPlugins::StatusHandler
  class << self
    # source://roda//lib/roda/plugins/status_handler.rb#35
    def configure(app); end
  end
end

# source://roda//lib/roda/plugins/status_handler.rb#32
Roda::RodaPlugins::StatusHandler::CLEAR_HEADERS = T.let(T.unsafe(nil), Proc)

# source://roda//lib/roda/plugins/status_handler.rb#39
module Roda::RodaPlugins::StatusHandler::ClassMethods
  # Freeze the hash of status handlers so that there can be no thread safety issues at runtime.
  #
  # source://roda//lib/roda/plugins/status_handler.rb#66
  def freeze; end

  # Install the given block as a status handler for the given HTTP response code.
  #
  # source://roda//lib/roda/plugins/status_handler.rb#41
  def status_handler(code, opts = T.unsafe(nil), &block); end
end

# source://roda//lib/roda/plugins/status_handler.rb#72
module Roda::RodaPlugins::StatusHandler::InstanceMethods
  private

  # If routing returns a response we have a handler for, call that handler.
  #
  # source://roda//lib/roda/plugins/status_handler.rb#76
  def _roda_after_20__status_handler(result); end
end

# Base class used for Roda requests.  The instance methods for this
# class are added by Roda::RodaPlugins::Base::RequestMethods, the
# class methods are added by Roda::RodaPlugins::Base::RequestClassMethods.
#
# source://roda//lib/roda/request.rb#21
class Roda::RodaRequest < ::Rack::Request
  include ::Roda::RodaPlugins::Base::RequestMethods
  extend ::Roda::RodaPlugins::Base::RequestClassMethods
end

# Base class used for Roda responses.  The instance methods for this
# class are added by Roda::RodaPlugins::Base::ResponseMethods, the class
# methods are added by Roda::RodaPlugins::Base::ResponseClassMethods.
#
# source://roda//lib/roda/response.rb#12
class Roda::RodaResponse
  include ::Roda::RodaPlugins::Base::ResponseMethods
  extend ::Roda::RodaPlugins::Base::ResponseClassMethods
end

# The full version of Roda as a string.
#
# source://roda//lib/roda/version.rb#14
Roda::RodaVersion = T.let(T.unsafe(nil), String)

# The full version of Roda as a number (3.7.0 => 30070)
#
# source://roda//lib/roda/version.rb#17
Roda::RodaVersionNumber = T.let(T.unsafe(nil), Integer)
